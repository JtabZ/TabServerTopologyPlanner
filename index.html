<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tableau Topology Planner - Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .info-tooltip-container {
            position: relative;
            display: inline-block;
        }

        .info-tooltip {
            visibility: hidden;
            min-width: 350px;
            max-width: 400px;
            white-space: normal;
            background-color: #1f2937;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.875rem;
            line-height: 1.25rem;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 8px;
        }
        
        .info-tooltip::before {
            content: "";
            position: absolute;
            top: 50%;
            right: 100%;
            margin-top: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent #1f2937 transparent transparent;
        }

        .info-tooltip-container:hover .info-tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        .info-tooltip-content {
            display: block;
            margin-top: 4px;
        }

        tbody tr:hover {
            position: relative;
            z-index: 25;
        }
        
        .auto-managed {
            background-color: #f3f4f6;
            cursor: not-allowed;
        }
        
        .auto-managed-label {
            background-color: #e5e7eb;
            color: #6b7280;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 4px;
        }
    </style>
</head>
<body class="h-full font-sans">
    <div class="container mx-auto p-4 md:p-8">
        
        <!-- Header -->
        <div class="mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Tableau Topology Planner</h1>
            <p class="text-lg text-gray-600 mt-1">Design and validate your Tableau Server architecture against best practices.</p>
            <p class="text-sm text-blue-600 mt-1">✨ Enhanced with automatic process management and dependency tracking</p>
        </div>

        <!-- Controls -->
        <div class="bg-white p-4 rounded-lg shadow-sm mb-6 flex flex-wrap items-center gap-4">
            <div>
                <label for="node-count" class="block text-sm font-medium text-gray-700">Nodes</label>
                <input type="number" id="node-count" value="4" min="1" max="20" class="mt-1 block w-24 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
            </div>
            <button id="build-grid" class="bg-blue-600 text-white px-4 py-2 rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                Build Topology Grid
            </button>
            <button id="toggle-graphic" class="bg-gray-200 text-gray-800 px-4 py-2 rounded-md shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                Toggle Graphic View
            </button>
            
            <button id="export-config" class="bg-green-600 text-white px-4 py-2 rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                Export Config
            </button>
            <button id="import-config-btn" class="bg-white text-gray-700 px-4 py-2 rounded-md shadow-sm border border-gray-300 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                Import Config
            </button>
            <input type="file" id="import-file" accept=".json" class="hidden">
            
            <button id="reset-grid" class="bg-red-600 text-white px-4 py-2 rounded-md shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2">
                Reset
            </button>
            
            <div class="ml-auto flex items-center gap-2">
                <span class="text-xl font-bold text-gray-800">Total Cores:</span>
                <span id="total-core-display" class="text-2xl font-bold text-blue-600">0</span>
            </div>
        </div>

        <!-- Main Content: Table and Notes -->
        <div class="flex flex-col lg:flex-row gap-6">
            
            <!-- Topology Table (no scrolling) -->
            <div class="flex-grow lg:w-3/4">
                <div id="table-container" class="bg-white rounded-lg shadow">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead id="topology-head" class="bg-gray-50 sticky top-0">
                            <!-- Header row will be built by JS -->
                        </thead>
                        <tbody id="topology-body" class="divide-y divide-gray-200 bg-white">
                            <!-- Body rows will be built by JS -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Best Practices & Alerts -->
            <div class="lg:w-1/4">
                <div class="bg-white p-4 rounded-lg shadow sticky top-8">
                    <h3 class="text-lg font-semibold text-gray-900 border-b border-gray-200 pb-2">Best Practices & Alerts</h3>
                    <div id="notes-container" class="mt-3 max-h-96 overflow-y-auto">
                        <p class="text-sm text-gray-500">Change process counts to see real-time recommendations based on the Tableau Architecture Playbook.</p>
                        <ul id="notes-list" class="list-none space-y-2 mt-2">
                            <!-- Notes will be added by JS -->
                        </ul>
                    </div>
                </div>
            </div>

        </div>

    </div>

    <script>
        // ===== PROCESS CONFIGURATION =====
        // Define which processes are user-configurable vs automatically managed
        const processConfig = {
            // User-configurable processes (from Architecture Playbook)
            'vizqlserver': {
                userConfigurable: true,
                purpose: 'Responsible for viz generation and interaction, including web authoring',
                notes: 'Each VizQL process needs 4 cores. Ideal: 16 cores for 4 VizQL instances (max recommended per node).',
                licensed: 'Yes',
                autoInstalls: ['gateway', 'hyper'],
                guidanceRules: [
                    { condition: (count, cores) => count > 0 && cores < count * 4, message: (count, cores) => 'Insufficient cores: ' + count + ' VizQL instance' + (count > 1 ? 's' : '') + ' need' + (count === 1 ? 's' : '') + ' at least ' + (count * 4) + ' cores (4 cores per instance)', severity: 'error' },
                    { condition: (count, cores) => count > Math.floor(cores / 4), message: (count, cores) => 'Too many VizQL instances for available cores. Maximum recommended: ' + Math.floor(cores / 4), severity: 'error' },
                    { condition: (count) => count > 4, message: (count) => 'More than 4 VizQL instances per node shows diminishing returns', severity: 'warning' }
                ]
            },
            'backgrounder': {
                userConfigurable: true,
                purpose: 'Runs server tasks: extract refreshes, subscriptions, Run Now tasks',
                notes: 'Single-threaded. Isolated: cores/2 to cores/1.5. Co-located: cores/4 to cores/2',
                licensed: 'Yes',
                autoInstalls: ['hyper'],
                guidanceRules: [
                    { condition: (count, cores, node) => count > Math.floor(cores / 2), message: 'Too many Backgrounder instances. Isolated max: cores/2', severity: 'error' },
                    { condition: (count, cores, node) => hasVizQL(node) && count > 0, message: 'Backgrounder should be isolated from VizQL for best performance', severity: 'warning' }
                ]
            },
            'cacheserver': {
                userConfigurable: true,
                purpose: 'Query cache distributed across the cluster',
                notes: 'Single-threaded. Max 6 instances cluster-wide, max 2 per node',
                licensed: 'No',
                guidanceRules: [
                    { condition: (count) => count > 2, message: 'Max 2 Cache Server instances per node recommended', severity: 'warning' },
                    { condition: (count, cores, node, allNodes) => getTotalProcessCount(allNodes, 'cacheserver') > 6, message: 'More than 6 Cache Servers cluster-wide provides no benefit', severity: 'warning' }
                ]
            },
            'dataserver': {
                userConfigurable: true,
                purpose: 'Manages connections to published data sources',
                notes: '2 per machine for redundancy. More than 2 dilutes in-memory caches',
                licensed: 'Yes',
                autoInstalls: ['hyper'],
                guidanceRules: [
                    { condition: (count) => count > 2, message: 'More than 2 Data Server instances per node can reduce performance', severity: 'warning' }
                ]
            },
            'filestore': {
                userConfigurable: true,
                purpose: 'Stores and replicates extracts across the cluster',
                notes: 'Recommended: 3 per environment for HA balance',
                licensed: 'No',
                autoInstalls: ['hyper'],
                guidanceRules: [
                    { condition: (count, cores, node, allNodes) => getTotalProcessCount(allNodes, 'filestore') < 2, message: 'At least 2 File Store instances recommended for redundancy', severity: 'info' },
                    { condition: (count, cores, node, allNodes) => getTotalProcessCount(allNodes, 'filestore') > 3, message: 'More than 3 File Store instances increases replication traffic', severity: 'info' }
                ]
            },
            'vizportal': {
                userConfigurable: true,
                purpose: 'Handles web UI, REST API, authentication, publishing',
                notes: 'Pairs well with VizQL Server (heavily reliant on each other)',
                licensed: 'Yes',
                autoInstalls: ['hyper', 'analyticsextensions'],
                guidanceRules: []
            },
            'pgsql': {
                userConfigurable: true,
                purpose: 'PostgreSQL repository - stores all metadata',
                notes: 'Max 2 instances (active/passive). Requires 3+ nodes for passive',
                licensed: 'No',
                guidanceRules: [
                    { condition: (count, cores, node, allNodes) => getTotalProcessCount(allNodes, 'pgsql') > 2, message: 'Maximum 2 Repository instances (active + passive) per cluster', severity: 'error' },
                    { condition: (count, cores, node, allNodes) => getTotalProcessCount(allNodes, 'pgsql') === 2 && allNodes.length < 3, message: 'Passive repository requires 3+ nodes in cluster', severity: 'error' }
                ]
            },
            'gateway': {
                userConfigurable: true,
                purpose: 'Apache web server - handles all HTTP(S) requests',
                notes: 'Required on nodes with VizQL, VizPortal, or Flow Authoring',
                licensed: 'No',
                guidanceRules: []
            },
            'flowprocessor': {
                userConfigurable: true,
                purpose: 'Tableau Prep Conductor - runs and schedules flows',
                notes: 'Automatically enabled where Backgrounder is enabled (unless excluded via node role)',
                licensed: 'Yes',
                guidanceRules: [
                    { condition: (count, cores, node) => count > 0 && node.backgrounder === 0, message: 'Prep Conductor requires Backgrounder on the same node', severity: 'error' }
                ]
            },
            'floweditor': {
                userConfigurable: true,
                purpose: 'Provides interactive Prep Flow authoring in browser',
                notes: 'Requires flowqueryservice, hyper, and gateway',
                licensed: 'Yes',
                autoInstalls: ['flowminerva', 'hyper', 'gateway'],
                guidanceRules: []
            },
            'indexandsearchserver': {
                userConfigurable: true,
                purpose: 'AWS OpenSearch based indexing for Ask Data and Content Exploration',
                notes: 'Recommend odd number of instances (3 or 5) across different nodes',
                licensed: 'No',
                guidanceRules: [
                    { condition: (count, cores, node, allNodes) => {
                        const total = getTotalProcessCount(allNodes, 'indexandsearchserver');
                        return total > 0 && total % 2 === 0;
                    }, message: 'Recommend odd number of Index and Search Server instances cluster-wide', severity: 'info' }
                ]
            },
            'vizdataservice': {
                userConfigurable: true,
                purpose: 'Manages connections to published data sources on Tableau Server',
                notes: 'Added in 2024.2. One or more instances installed on initial node. At least one instance required.',
                licensed: 'Yes',
                autoInstalls: ['vizdatanativeservice'],
                guidanceRules: [
                    { condition: (count, cores, node, allNodes) => getTotalProcessCount(allNodes, 'vizdataservice') === 0, message: 'At least one instance of VizData Service is required (as of 2024.2.3)', severity: 'error' }
                ]
            },
            
            // Auto-managed processes (cannot be manually configured)
            'hyper': {
                userConfigurable: false,
                purpose: 'Data Engine - creates, refreshes, and queries extracts',
                notes: 'Automatically collocated with VizQL, Backgrounder, Data Server, File Store, Flow Editor',
                licensed: 'Yes',
                autoConditions: [
                    { processes: ['vizqlserver', 'backgrounder', 'dataserver', 'filestore', 'vizportal', 'floweditor'] }
                ]
            },
            'clustercontroller': {
                userConfigurable: false,
                purpose: 'Monitors components, detects failures, runs failover',
                notes: 'Automatically installed on every node',
                licensed: 'No',
                autoConditions: [{ always: true }]
            },
            'gateway_auto': {
                userConfigurable: false,
                purpose: 'Auto-installed with VizQL, VizPortal, or Flow Editor',
                notes: 'Gateway is required on nodes with these processes',
                licensed: 'No',
                autoConditions: [
                    { processes: ['vizqlserver', 'vizportal', 'floweditor'] }
                ]
            },
            'analyticsextensions': {
                userConfigurable: false,
                purpose: 'Supports R, Python, Einstein Discovery integration',
                notes: 'Automatically installed on any node where Application Server (VizPortal) is installed',
                licensed: 'No',
                autoConditions: [
                    { processes: ['vizportal'] }
                ]
            },
            'flowminerva': {
                userConfigurable: false,
                purpose: 'Used by Flow Authoring for querying datasources',
                notes: 'Automatically enabled where Flow Authoring (floweditor) is enabled',
                licensed: 'Yes',
                autoConditions: [
                    { processes: ['floweditor'] }
                ]
            },
            'vizdatanativeservice': {
                userConfigurable: false,
                purpose: 'Communicates with the VizData Service on Tableau Server',
                notes: 'Automatically added for each instance of VizData Service (Added in 2024.2)',
                licensed: 'Yes',
                autoConditions: [
                    { processes: ['vizdataservice'] }
                ]
            }
        };

        // List of user-configurable processes for the UI
        const processes = Object.keys(processConfig).filter(p => processConfig[p].userConfigurable).sort();
        
        // Auto-managed processes to track and display
        const autoManagedProcesses = Object.keys(processConfig).filter(p => !processConfig[p].userConfigurable).sort();

        let isGraphicView = false;

        // ===== HELPER FUNCTIONS =====
        
        function hasVizQL(nodeData) {
            return nodeData && nodeData.vizqlserver > 0;
        }
        
        function getTotalProcessCount(allNodes, processName) {
            return allNodes.reduce((sum, node) => sum + (node[processName] || 0), 0);
        }
        
        function calculateAutoManagedProcesses(nodeIndex) {
            const nodeData = getCurrentNodeData(nodeIndex);
            const autoManaged = {};
            
            autoManagedProcesses.forEach(processName => {
                const config = processConfig[processName];
                let shouldInstall = 0;
                
                if (config.autoConditions) {
                    for (const condition of config.autoConditions) {
                        if (condition.always) {
                            shouldInstall = 1;
                            break;
                        }
                        if (condition.processes) {
                            // Special handling for vizdatanativeservice - match count of vizdataservice
                            if (processName === 'vizdatanativeservice' && condition.processes.includes('vizdataservice')) {
                                shouldInstall = nodeData['vizdataservice'] || 0;
                                break;
                            } else {
                                // For other processes, install 1 instance if any trigger process exists
                                shouldInstall = condition.processes.some(p => nodeData[p] > 0) ? 1 : 0;
                                if (shouldInstall) break;
                            }
                        }
                    }
                }
                
                autoManaged[processName] = shouldInstall;
            });
            
            return autoManaged;
        }
        
        function getCurrentNodeData(nodeIndex) {
            const data = {};
            processes.forEach(processName => {
                const input = document.querySelector(`input[data-process="${processName}"][data-node-index="${nodeIndex}"]`);
                data[processName] = input ? parseInt(input.value, 10) || 0 : 0;
            });
            return data;
        }
        
        function getAllNodesData() {
            const nodeCount = parseInt(document.getElementById('node-count').value, 10) || 1;
            const nodes = [];
            for (let i = 0; i < nodeCount; i++) {
                nodes.push(getCurrentNodeData(i));
            }
            return nodes;
        }

        // ===== BUILD TOPOLOGY GRID =====
        
        function buildTopologyGrid() {
            const nodeCount = parseInt(document.getElementById('node-count').value, 10) || 1;
            const theadRow = document.getElementById('topology-head');
            const tbody = document.getElementById('topology-body');
            
            theadRow.innerHTML = '';
            tbody.innerHTML = '';
            isGraphicView = false;

            // Header row
            let headerHTML = '<tr><th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Process</th>';
            for (let i = 0; i < nodeCount; i++) {
                headerHTML += `
                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                        Node ${i + 1}
                        <div class="mt-1">
                            <input type="number" 
                                   class="core-count-input w-16 text-center rounded border-gray-300 text-sm" 
                                   data-node-index="${i}" 
                                   value="8" 
                                   min="4" 
                                   max="64" 
                                   placeholder="Cores">
                            <div class="text-xs text-gray-400 mt-1">cores</div>
                        </div>
                        <div class="mt-2">
                            <select class="copy-to-select w-full text-xs rounded border-gray-300" data-node-index="${i}">
                                <option value="">Copy to...</option>
                                ${Array.from({length: nodeCount}, (_, j) => j !== i ? `<option value="${j}">Node ${j + 1}</option>` : '').join('')}
                            </select>
                        </div>
                    </th>
                `;
            }
            headerHTML += '</tr>';
            theadRow.innerHTML = headerHTML;

            // User-configurable processes
            processes.forEach(processName => {
                const config = processConfig[processName];
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50';
                
                let rowHTML = `
                    <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">
                        <div class="flex items-center">
                            <span>${processName}</span>
                            <span class="total-process-count ml-2 text-xs font-normal text-gray-500" data-process="${processName}">(0)</span>
                            <div class="info-tooltip-container">
                                <svg class="w-4 h-4 ml-2 text-blue-500 cursor-help" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                                </svg>
                                <div class="info-tooltip">
                                    <strong>Purpose:</strong> ${config.purpose}
                                    <div class="info-tooltip-content"><strong>Notes:</strong> ${config.notes}</div>
                                    <div class="info-tooltip-content"><strong>Licensed:</strong> ${config.licensed}</div>
                                </div>
                            </div>
                        </div>
                    </td>
                `;
                
                for (let i = 0; i < nodeCount; i++) {
                    rowHTML += `
                        <td class="px-4 py-2 text-center">
                            <input type="number" 
                                   class="process-input w-16 text-center rounded border-gray-300 py-1" 
                                   data-process="${processName}" 
                                   data-node-index="${i}" 
                                   value="0" 
                                   min="0" 
                                   max="20">
                            <div class="graphic-view hidden text-green-600 font-bold"></div>
                        </td>
                    `;
                }
                
                row.innerHTML = rowHTML;
                tbody.appendChild(row);
            });
            
            // Auto-managed processes (read-only display)
            autoManagedProcesses.forEach(processName => {
                const config = processConfig[processName];
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50 bg-gray-50';
                
                let rowHTML = `
                    <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-700">
                        <div class="flex items-center">
                            <span>${processName}</span>
                            <span class="total-process-count ml-2 text-xs font-normal text-gray-500" data-process="${processName}">(0)</span>
                            <span class="auto-managed-label">AUTO</span>
                            <div class="info-tooltip-container">
                                <svg class="w-4 h-4 ml-2 text-blue-500 cursor-help" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                                </svg>
                                <div class="info-tooltip">
                                    <strong>Purpose:</strong> ${config.purpose}
                                    <div class="info-tooltip-content"><strong>Notes:</strong> ${config.notes}</div>
                                    <div class="info-tooltip-content"><strong>Licensed:</strong> ${config.licensed}</div>
                                    <div class="info-tooltip-content"><em>This process is automatically managed and cannot be manually configured.</em></div>
                                </div>
                            </div>
                        </div>
                    </td>
                `;
                
                for (let i = 0; i < nodeCount; i++) {
                    rowHTML += `
                        <td class="px-4 py-2 text-center">
                            <div class="auto-managed-display font-mono text-sm text-gray-600" 
                                 data-process="${processName}" 
                                 data-node-index="${i}">0</div>
                        </td>
                    `;
                }
                
                row.innerHTML = rowHTML;
                tbody.appendChild(row);
            });

            // Attach event listeners
            document.querySelectorAll('.process-input').forEach(input => {
                input.addEventListener('input', () => {
                    const nodeIndex = input.dataset.nodeIndex;
                    updateAutoManagedProcesses(nodeIndex);
                    updateAll();
                });
            });
            
            document.querySelectorAll('.core-count-input').forEach(input => {
                input.addEventListener('input', updateAll);
            });
            
            document.querySelectorAll('.copy-to-select').forEach(select => {
                select.addEventListener('change', (e) => copyNodeConfiguration(e.target));
            });

            updateAll();
        }

        // ===== UPDATE FUNCTIONS =====
        
        function updateAutoManagedProcesses(nodeIndex) {
            const autoManaged = calculateAutoManagedProcesses(nodeIndex);
            
            Object.keys(autoManaged).forEach(processName => {
                const displayElement = document.querySelector(
                    `.auto-managed-display[data-process="${processName}"][data-node-index="${nodeIndex}"]`
                );
                if (displayElement) {
                    displayElement.textContent = autoManaged[processName];
                }
            });
        }
        
        function updateAllAutoManagedProcesses() {
            const nodeCount = parseInt(document.getElementById('node-count').value, 10) || 1;
            for (let i = 0; i < nodeCount; i++) {
                updateAutoManagedProcesses(i);
            }
        }

        function updateTotalCores() {
            let totalCores = 0;
            document.querySelectorAll('.core-count-input').forEach(input => {
                totalCores += parseInt(input.value, 10) || 0;
            });
            document.getElementById('total-core-display').textContent = totalCores;
        }
        
        function updateProcessTotals() {
            const allNodes = getAllNodesData();
            
            // Update user-configurable process totals
            processes.forEach(processName => {
                const total = getTotalProcessCount(allNodes, processName);
                const totalElement = document.querySelector(`.total-process-count[data-process="${processName}"]`);
                if (totalElement) {
                    totalElement.textContent = `(${total})`;
                }
            });
            
            // Update auto-managed process totals
            autoManagedProcesses.forEach(processName => {
                let total = 0;
                document.querySelectorAll(`.auto-managed-display[data-process="${processName}"]`).forEach(el => {
                    total += parseInt(el.textContent, 10) || 0;
                });
                const totalElement = document.querySelector(`.total-process-count[data-process="${processName}"]`);
                if (totalElement) {
                    totalElement.textContent = `(${total})`;
                }
            });
        }

        function updateNotes() {
            const notesList = document.getElementById('notes-list');
            notesList.innerHTML = '';
            const allNodes = getAllNodesData();
            const nodeCount = allNodes.length;

            processes.forEach(processName => {
                const config = processConfig[processName];
                if (!config.guidanceRules || config.guidanceRules.length === 0) return;

                for (let nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++) {
                    const coresInput = document.querySelector(`input.core-count-input[data-node-index="${nodeIndex}"]`);
                    const cores = parseInt(coresInput?.value, 10) || 8;
                    const processCount = allNodes[nodeIndex][processName] || 0;

                    config.guidanceRules.forEach(rule => {
                        if (rule.condition(processCount, cores, allNodes[nodeIndex], allNodes)) {
                            const li = document.createElement('li');
                            const severityClass = {
                                'error': 'bg-red-50 border-red-300 text-red-800',
                                'warning': 'bg-yellow-50 border-yellow-300 text-yellow-800',
                                'info': 'bg-blue-50 border-blue-300 text-blue-800'
                            }[rule.severity] || 'bg-gray-50 border-gray-300 text-gray-800';

                            // Handle message as either a function or a string
                            const messageText = typeof rule.message === 'function' 
                                ? rule.message(processCount, cores, allNodes[nodeIndex], allNodes)
                                : rule.message;

                            li.className = `p-2 rounded border ${severityClass} text-sm`;
                            li.innerHTML = `<strong>Node ${nodeIndex + 1} - ${processName}:</strong> ${messageText}`;
                            notesList.appendChild(li);
                        }
                    });
                }
            });

            if (notesList.children.length === 0) {
                const li = document.createElement('li');
                li.className = 'p-2 rounded bg-green-50 border border-green-300 text-green-800 text-sm';
                li.innerHTML = '✓ Configuration looks good! No major issues detected.';
                notesList.appendChild(li);
            }
        }

        function updateAll() {
            updateAllAutoManagedProcesses();
            updateTotalCores();
            updateProcessTotals();
            updateNotes();
        }

        // ===== COPY NODE CONFIGURATION =====
        
        function copyNodeConfiguration(selectElement) {
            const sourceNodeIndex = selectElement.dataset.nodeIndex;
            const targetNodeIndex = selectElement.value;
            
            if (targetNodeIndex === "") return;

            // Copy core count
            const sourceCoreInput = document.querySelector(`input.core-count-input[data-node-index="${sourceNodeIndex}"]`);
            const targetCoreInput = document.querySelector(`input.core-count-input[data-node-index="${targetNodeIndex}"]`);
            if (sourceCoreInput && targetCoreInput) {
                targetCoreInput.value = sourceCoreInput.value;
            }

            // Copy all process counts
            processes.forEach(processName => {
                const sourceProcessInput = document.querySelector(`input[data-process="${processName}"][data-node-index="${sourceNodeIndex}"]`);
                const targetProcessInput = document.querySelector(`input[data-process="${processName}"][data-node-index="${targetNodeIndex}"]`);
                
                if (sourceProcessInput && targetProcessInput) {
                    targetProcessInput.value = sourceProcessInput.value;
                }
            });

            // Update auto-managed processes for target node
            updateAutoManagedProcesses(targetNodeIndex);

            // Reset dropdown
            selectElement.value = "";

            // Update everything
            updateAll();
        }

        // ===== TOGGLE GRAPHIC VIEW =====
        
        function toggleGraphicView() {
            isGraphicView = !isGraphicView;
            const toggleButton = document.getElementById('toggle-graphic');
            const inputs = document.querySelectorAll('.process-input');
            const graphics = document.querySelectorAll('.graphic-view');

            if (isGraphicView) {
                toggleButton.textContent = 'Toggle Input View';
                toggleButton.classList.remove('bg-gray-200', 'text-gray-800', 'hover:bg-gray-300');
                toggleButton.classList.add('bg-green-600', 'text-white', 'hover:bg-green-700');
                
                inputs.forEach(input => {
                    input.classList.add('hidden');
                    const graphicEl = input.nextElementSibling;
                    const value = parseInt(input.value, 10);
                    
                    let checks = '';
                    if (value > 0 && value <= 4) {
                        checks = '✓'.repeat(value);
                    } else if (value > 4) {
                        checks = `✓ x ${value}`;
                    }
                    graphicEl.textContent = checks;
                    graphicEl.classList.remove('hidden');
                });

            } else {
                toggleButton.textContent = 'Toggle Graphic View';
                toggleButton.classList.add('bg-gray-200', 'text-gray-800', 'hover:bg-gray-300');
                toggleButton.classList.remove('bg-green-600', 'text-white', 'hover:bg-green-700');
                
                inputs.forEach(input => {
                    input.classList.remove('hidden');
                    input.nextElementSibling.classList.add('hidden');
                });
            }
        }

        // ===== RESET GRID =====
        
        function resetGrid() {
            document.getElementById('node-count').value = 4;
            buildTopologyGrid();
            updateAll();

            const toggleButton = document.getElementById('toggle-graphic');
            toggleButton.textContent = 'Toggle Graphic View';
            toggleButton.classList.add('bg-gray-200', 'text-gray-800', 'hover:bg-gray-300');
            toggleButton.classList.remove('bg-green-600', 'text-white', 'hover:bg-green-700');
        }

        // ===== EXPORT/IMPORT =====
        
        function exportConfig() {
            try {
                const nodeCount = parseInt(document.getElementById('node-count').value, 10) || 1;
                let config = {
                    nodeCount: nodeCount,
                    nodes: []
                };

                for (let i = 0; i < nodeCount; i++) {
                    const coreInput = document.querySelector(`input.core-count-input[data-node-index="${i}"]`);
                    let nodeData = {
                        cores: coreInput ? parseInt(coreInput.value, 10) : 8,
                        processes: {}
                    };

                    processes.forEach(processName => {
                        const processInput = document.querySelector(`input[data-process="${processName}"][data-node-index="${i}"]`);
                        if (processInput) {
                            nodeData.processes[processName] = parseInt(processInput.value, 10) || 0;
                        }
                    });
                    config.nodes.push(nodeData);
                }

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "tableau-topology.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            } catch (error) {
                console.error("Error exporting config:", error);
            }
        }

        function importConfig(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const config = JSON.parse(e.target.result);

                    if (!config || typeof config.nodeCount !== 'number' || !Array.isArray(config.nodes)) {
                        console.error("Invalid config file format.");
                        return;
                    }

                    document.getElementById('node-count').value = config.nodeCount;
                    buildTopologyGrid();

                    for (let i = 0; i < config.nodeCount; i++) {
                        const nodeData = config.nodes[i];
                        if (!nodeData) continue;

                        const coreInput = document.querySelector(`input.core-count-input[data-node-index="${i}"]`);
                        if (coreInput && nodeData.cores) {
                            coreInput.value = nodeData.cores;
                        }

                        if (nodeData.processes) {
                            processes.forEach(processName => {
                                const processInput = document.querySelector(`input[data-process="${processName}"][data-node-index="${i}"]`);
                                if (processInput && typeof nodeData.processes[processName] === 'number') {
                                    processInput.value = nodeData.processes[processName];
                                }
                            });
                        }
                    }

                    updateAll();

                } catch (error) {
                    console.error("Error parsing config file:", error);
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        // ===== EVENT LISTENERS =====
        
        document.getElementById('build-grid').addEventListener('click', buildTopologyGrid);
        document.getElementById('toggle-graphic').addEventListener('click', toggleGraphicView);
        document.getElementById('reset-grid').addEventListener('click', resetGrid);
        document.getElementById('export-config').addEventListener('click', exportConfig);
        document.getElementById('import-config-btn').addEventListener('click', () => {
            document.getElementById('import-file').click();
        });
        document.getElementById('import-file').addEventListener('change', importConfig);

        // ===== INITIALIZE =====
        buildTopologyGrid();
    </script>
</body>
</html>
