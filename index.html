<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-50">
<head>
    <meta charset="UTF-g">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tableau Topology Planner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom style for the info tooltip */
        .info-tooltip-container {
            position: relative;
            display: inline-block;
        }

        .info-tooltip {
            visibility: hidden;
            /* width: 300px; */ /* Removed fixed width */
            min-width: 350px; /* <-- ADDED THIS */
            max-width: 400px; /* Added max-width */
            white-space: normal; /* Added for text wrapping */
            background-color: #1f2937; /* dark-gray */
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            
            /* Position to the right */
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 8px; /* small gap */
        }
        
        .info-tooltip::before {
            content: "";
            position: absolute;
            top: 50%;
            right: 100%; /* At the left edge of the tooltip */
            margin-top: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent #1f2937 transparent transparent;
        }

        .info-tooltip-container:hover .info-tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        .info-tooltip-content {
            display: block;
            margin-top: 4px;
        }

        /* --- FIX for tooltip clipping --- */
        /* When hovering a row, bring it and its children (like the tooltip)
           to the front so it's not clipped by subsequent rows. */
        tbody tr:hover {
            position: relative;
            z-index: 25;
        }
        /* --- End of fix --- */
    </style>
</head>
<body class="h-full font-sans">
    <div class="container mx-auto p-4 md:p-8">
        
        <!-- Header -->
        <div class="mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Tableau Topology Planner</h1>
            <p class="text-lg text-gray-600 mt-1">Design and validate your Tableau Server architecture against best practices.</p>
        </div>

        <!-- Controls -->
        <div class="bg-white p-4 rounded-lg shadow-sm mb-6 flex flex-wrap items-center gap-4">
            <div>
                <label for="node-count" class="block text-sm font-medium text-gray-700">Nodes</label>
                <input type="number" id="node-count" value="4" min="1" max="20" class="mt-1 block w-24 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
            </div>
            <button id="build-grid" class="bg-blue-600 text-white px-4 py-2 rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                Build Topology Grid
            </button>
            <button id="toggle-graphic" class="bg-gray-200 text-gray-800 px-4 py-2 rounded-md shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                Toggle Graphic View
            </button>
            
            <!-- NEW BUTTONS START -->
            <button id="export-config" class="bg-green-600 text-white px-4 py-2 rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                Export Config
            </button>
            <button id="import-config-btn" class="bg-white text-gray-700 px-4 py-2 rounded-md shadow-sm border border-gray-300 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                Import Config
            </button>
            <input type="file" id="import-file" accept=".json" class="hidden">
            
            <button id="reset-grid" class="bg-red-600 text-white px-4 py-2 rounded-md shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2">
                Reset
            </button>
            <!-- NEW BUTTONS END -->
            
            <div class="ml-auto flex items-center gap-2">
                <span class="text-xl font-bold text-gray-800">Total Cores:</span>
                <span id="total-core-display" class="text-2xl font-bold text-blue-600">0</span>
            </div>
        </div>

        <!-- Main Content: Table and Notes -->
        <div class="flex flex-col lg:flex-row gap-6">
            
            <!-- Topology Table (scrollable) -->
            <div class="flex-grow lg:w-3/4">
                <div id="table-container" class="overflow-x-auto bg-white rounded-lg shadow">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead id="topology-head" class="bg-gray-50 sticky top-0">
                            <!-- Header row will be built by JS -->
                        </thead>
                        <tbody id="topology-body" class="divide-y divide-gray-200 bg-white">
                            <!-- Body rows will be built by JS -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Best Practices & Alerts -->
            <div class="lg:w-1/4">
                <div class="bg-white p-4 rounded-lg shadow sticky top-8">
                    <h3 class="text-lg font-semibold text-gray-900 border-b border-gray-200 pb-2">Best Practices & Alerts</h3>
                    <div id="notes-container" class="mt-3 max-h-96 overflow-y-auto">
                        <p class="text-sm text-gray-500">Change process counts to see real-time recommendations based on the Tableau Architecture Playbook.</p>
                        <ul id="notes-list" class="list-none space-y-2 mt-2">
                            <!-- Notes will be added by JS -->
                        </ul>
                    </div>
                </div>
            </div>

        </div>

    </div>

    <script>
        // --- Process Info (from https://help.tableau.com/current/server/en-us/processes.htm) ---
        const allProcessInfo = {
            'activationservice': {
                purpose: 'Manages licensing for Tableau Server, including the activation, refresh, and deactivation of product keys.',
                notes: 'Required for Tableau Server to run. One instance is required.',
                licensed: 'No'
            },
            'activemqserver': {
                purpose: 'The message broker for Tableau Server. It provides a message service for all components.',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'analysisserver': {
                purpose: 'Manages the connection to analytic extensions.',
                notes: 'Previously called "R Server".',
                licensed: 'No'
            },
            'api-gateway': {
                purpose: 'Handles requests to the Tableau REST API.',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'authnservice': {
                purpose: 'Handles authentication requests and integration with identity providers (IdPs).',
                notes: 'One instance is required.',
                licensed: 'No'
            },
            'backgrounder': {
                purpose: 'Executes server tasks, including extract refreshes, subscriptions, flow runs, and data-driven alerts.',
                notes: 'Can be configured to run specific task types.',
                licensed: 'Yes'
            },
            'backupsrestore': {
                purpose: 'Handles backup and restore operations.',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'cacheservice': {
                purpose: 'A distributed in-memory cache for queries, workbook metadata, and more.',
                notes: 'Also known as "Cache Server". Uses Redis.',
                licensed: 'No'
            },
            'clientservice': {
                purpose: 'Handles client requests for the Tableau Server web interface.',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'collections': {
                purpose: 'Enables the "Collections" feature, allowing users to group and organize content.',
                notes: '',
                licensed: 'No'
            },
            'contentexploration': {
                purpose: 'Powers content recommendations and search result suggestions.',
                notes: '',
                licensed: 'No'
            },
            'databasemaintenance': {
                purpose: 'Handles database maintenance tasks.',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'dataserver': {
                purpose: 'Manages connections to Tableau Server data sources, both live and extracts.',
                notes: 'Handles Ask Data (NLP) queries.',
                licensed: 'No'
            },
            'datasourceproperties': {
                purpose: 'Manages datasource properties and metadata.',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'elasticserver': {
                purpose: 'Handles indexing for Ask Data (NLP).',
                notes: 'Used in versions prior to 2022.1. Replaced by Index and Search Server.',
                licensed: 'No'
            },
            'filestore': {
                purpose: 'Manages the storage and replication of data extracts (.hyper files) and flow files.',
                notes: 'At least one instance is required. Automatically installs Data Engine (hyper).',
                licensed: 'Yes'
            },
            'floweditor': {
                purpose: 'Enables editing of Tableau Prep flows directly in the web interface.',
                notes: 'Requires Data Management Add-on. This process is not user-configurable.',
                licensed: 'Yes'
            },
            'flowprocessor': {
                purpose: 'Handles the execution of flow-related tasks initiated by the user.',
                notes: 'This process is not user-configurable.',
                licensed: 'Yes'
            },
            'gateway': {
                purpose: 'Acts as a reverse proxy and load balancer, routing requests to the appropriate Tableau Server components.',
                notes: 'One instance is required on each node.',
                licensed: 'No'
            },
            'hyper': {
                purpose: 'The Tableau Data Engine. Handles all tasks related to creating, refreshing, and querying data extracts.',
                notes: 'Not directly configurable. Automatically installed with processes that depend on it (VizQL, Backgrounder, Data Server, File Store, Vizportal).',
                licensed: 'Yes'
            },
            'indexandsearchserver': {
                purpose: 'Powers fast search, filter, and display of content on the server.',
                notes: 'Replaces Search & Browse and Elastic Server (for Ask Data) as of 2022.1.',
                licensed: 'No'
            },
            'interactive': {
                purpose: 'Powers interactive dashboards and worksheets. This process is not user-configurable.',
                notes: '',
                licensed: 'Yes'
            },
            'metrics': {
                purpose: 'Handles the creation, refresh, and display of Metrics.',
                notes: 'This feature was retired in 2023.3.',
                licensed: 'Yes'
            },
            'minerva': {
                purpose: 'Handles communication between data sources.',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'noninteractive': {
                purpose: 'Handles background rendering tasks, like for subscriptions.',
                notes: 'This process is not user-configurable.',
                licensed: 'Yes'
            },
            'pgsql': {
                purpose: 'The Tableau Server repository, a PostgreSQL database that stores all metadata for workbooks, users, permissions, and more.',
                notes: 'Only one active instance can exist. A passive instance can be configured for HA.',
                licensed: 'No'
            },
            'publishedconnections': {
                purpose: 'Manages published data source connections.',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'querygateway': {
                purpose: 'Manages requests for Ask Data (NLP).',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'siteimports': {
                purpose: 'Handles the import of sites.',
                notes: 'This process is not user-configurable.',
                licensed: 'No'
            },
            'tabadmincontroller': {
                purpose: 'The TSM (Tableau Services Manager) controller for managing the server configuration and topology.',
                notes: 'One instance is required on each node.',
                licensed: 'No'
            },
            'vizportal': {
                purpose: 'The main web application for Tableau Server. Handles browsing, searching, permissions, and the web authoring UI.',
                notes: 'Also known as "Application Server".',
                licensed: 'No'
            },
            'vizqlserver': {
                purpose: 'Renders visualizations and handles user interactions with views (e.g., filtering, tooltips).',
                notes: 'A core, CPU-intensive process.',
                licensed: 'Yes'
            },
            'webhooks': {
                purpose: 'Manages outbound webhook notifications.',
                notes: '',
                licensed: 'No'
            }
        };

        // --- Process List (from URL) ---
        const fullProcessList = [
            'activationservice', 'activemqserver', 'analysisserver', 'api-gateway', 'authnservice',
            'backgrounder', 'backupsrestore', 'cacheservice', 'clientservice', 'collections',
            'contentexploration', 'databasemaintenance', 'dataserver', 'datasourceproperties', 'elasticserver',
            'filestore', 'floweditor', 'flowprocessor', 'gateway', 'hyper', 'indexandsearchserver',
            'interactive', 'metrics', 'minerva', 'noninteractive', 'pgsql', 'publishedconnections',
            'querygateway', 'siteimports', 'tabadmincontroller', 'vizportal', 'vizqlserver', 'webhooks'
        ];
        
        // --- Create a filtered list of only user-configurable processes ---
        const processes = fullProcessList.filter(p => {
            const info = allProcessInfo[p];
            if (!info || !info.notes) return true; // Keep if no info or no notes
            if (p === 'hyper') return true; // Keep hyper, we handle it specially
            return !info.notes.includes("not user-configurable");
        });
        
        // --- Best Practice Rules (from Playbook) ---
        const rules = {
            'vizqlserver': {
                maxPerNode: 4,
                notes: [
                    { triggerValue: 4, text: "4 VizQL Servers is best on 16+ cores." }
                ]
            },
            'cacheservice': {
                maxTotal: 6,
                notes: [
                    { triggerTotal: 7, text: "More than 6 Cache Servers creates unnecessary traffic and diminishing returns." },
                    { triggerTotal: 1, text: "At least 2 Cache Servers are recommended for HA." }
                ]
            },
            'dataserver': {
                maxPerNode: 2,
                notes: [
                    { triggerValue: 3, text: "More than 2 Data Servers per node is not recommended unless needed by Ask Data." }
                ]
            },
            'filestore': {
                maxPerNode: 1
            },
            'hyper': {
                maxPerNode: 1,
                // 'hyper' is co-located automatically, so a manual value > 1 is wrong.
                notes: [
                    { triggerValue: 2, text: "'hyper' (Data Engine) is limited to 1 per node and is set automatically. Do not add it manually." }
                ]
            },
            'pgsql': {
                maxTotal: 2,
                maxPerNode: 1,
                notes: [
                    { triggerTotal: 3, text: "Only one active and one passive 'pgsql' (Repository) instance are allowed." }
                ]
            },
            'backgrounder': {
                // No hard max, but rules are based on cores (checked in updateBestPractices)
            },
            'indexandsearchserver': {
                notes: [
                    { triggerTotal: 2, text: "An odd number (e.g., 1, 3, 5) of Index and Search Servers is recommended for HA." },
                    { triggerTotal: 4, text: "An odd number (e.g., 1, 3, 5) of Index and Search Servers is recommended for HA." }
                ]
            },
            'gateway': {
                notes: [
                    { triggerValue: 0, text: "At least one 'gateway' is required on every node." }
                ]
            },
            'tabadmincontroller': {
                notes: [
                    { triggerValue: 0, text: "At least one 'tabadmincontroller' is required on every node." }
                ]
            }
        };

        // --- Node Templates (from Playbook & Help Docs) ---
        // Templates are now filtered to only include configurable processes
        const templates = {
            "Analytics Node": {
                'vizportal': 2, 'vizqlserver': 2, 'cacheservice': 2, 'dataserver': 2,
                'gateway': 1, 'indexandsearchserver': 1, 'filestore': 1, 'tabadmincontroller': 1, 'activationservice': 1, 'authnservice': 1,
            },
            "Backgrounder Node": {
                'backgrounder': 4,
                'gateway': 1, 'tabadmincontroller': 1, 'activationservice': 1, 'authnservice': 1,
            },
            "Gateway Only": {
                'gateway': 1, 'tabadmincontroller': 1, 'activationservice': 1, 'authnservice': 1
            },
            "Initial Node (Minimal)": {
                'gateway': 1, 'filestore': 1, 'pgsql': 1, 'vizportal': 1, 'vizqlserver': 1, 'cacheservice': 1, 'dataserver': 1,
                'indexandsearchserver': 1, 'backgrounder': 1, 'tabadmincontroller': 1, 'activationservice': 1, 'authnservice': 1,
            },
            "Initial Node (HA Main)": {
                'gateway': 1, 'pgsql': 1, 'vizportal': 2, 'vizqlserver': 2, 'cacheservice': 2, 'dataserver': 2,
                'indexandsearchserver': 1, 'filestore': 1, 'tabadmincontroller': 1, 'activationservice': 1, 'authnservice': 1,
            },
            "HA Worker (Passive)": {
                'gateway': 1, 'pgsql': 1, 'backgrounder': 4, 'vizportal': 2, 'vizqlserver': 2, 'cacheservice': 2, 'dataserver': 2,
                'indexandsearchserver': 1, 'filestore': 1, 'tabadmincontroller': 1, 'activationservice': 1, 'authnservice': 1,
            }
        };

        let isGraphicView = false;
        
        document.addEventListener('DOMContentLoaded', () => {
            const buildButton = document.getElementById('build-grid');
            const toggleButton = document.getElementById('toggle-graphic');
            const tableContainer = document.getElementById('table-container');

            // NEW: Get new buttons
            const exportButton = document.getElementById('export-config');
            const importButton = document.getElementById('import-config-btn');
            const importFileInput = document.getElementById('import-file');
            const resetButton = document.getElementById('reset-grid');

            buildButton.addEventListener('click', () => {
                buildTopologyGrid();
                updateAll();
            });
            toggleButton.addEventListener('click', toggleGraphicView);
            
            // NEW: Add new listeners
            exportButton.addEventListener('click', exportConfig);
            importButton.addEventListener('click', () => importFileInput.click());
            importFileInput.addEventListener('change', importConfig);
            resetButton.addEventListener('click', resetGrid);
            
            // Delegate events for dynamic inputs
            tableContainer.addEventListener('input', (e) => {
                if (e.target.matches('.process-input, .core-count-input')) {
                    if (e.target.matches('.process-input')) {
                        handleProcessInput(e.target);
                    }
                    updateAll();
                }
            });

            // Delegate events for template dropdowns
            tableContainer.addEventListener('change', (e) => {
                if (e.target.matches('.template-select')) {
                    applyTemplate(e.target);
                }
                if (e.target.matches('.copy-select')) {
                    handleCopyNode(e.target);
                }
            });

            // Initial build
            buildTopologyGrid();
            updateAll();
        });

        function buildTopologyGrid() {
            const nodeCountInput = document.getElementById('node-count');
            const head = document.getElementById('topology-head');
            const body = document.getElementById('topology-body');
            
            let nodeCount = parseInt(nodeCountInput.value, 10);
            if (nodeCount < 1 || isNaN(nodeCount)) {
                nodeCount = 1;
                nodeCountInput.value = 1;
            }

            // --- Build Header ---
            head.innerHTML = ''; // Clear existing header
            let headerRow = head.insertRow();
            let thProcess = document.createElement('th');
            thProcess.className = "sticky left-0 bg-gray-50 px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider z-10";
            thProcess.textContent = 'Process';
            headerRow.appendChild(thProcess);

            let thTotal = document.createElement('th');
            thTotal.className = "px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider";
            thTotal.textContent = 'Total Count';
            headerRow.appendChild(thTotal);

            for (let i = 1; i <= nodeCount; i++) {
                let thNode = document.createElement('th');
                thNode.className = "px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider";
                
                // Add Core Count Input
                let coreInputHtml = `
                    <div class="mb-1">
                        <label for="core-count-${i}" class="text-xs font-normal normal-case">Cores: </label>
                        <input type="number" id="core-count-${i}"
                               class="core-count-input w-16 text-xs p-1 border-gray-300 rounded-md shadow-sm"
                               value="8" min="4" data-node-index="${i - 1}">
                    </div>
                `;

                // Add "Apply Template" dropdown
                let select = document.createElement('select');
                select.className = "template-select mt-1 block w-full rounded-md border-gray-300 shadow-sm text-xs p-1";
                select.setAttribute('data-node-index', i - 1);
                select.innerHTML = '<option value="">Apply Template...</option>';
                for (const tplName in templates) {
                    let option = document.createElement('option');
                    option.value = tplName;
                    option.textContent = tplName;
                    select.appendChild(option);
                }
                
                // Add "Copy to..." dropdown
                let copySelect = document.createElement('select');
                copySelect.className = "copy-select mt-1 block w-full rounded-md border-gray-300 shadow-sm text-xs p-1";
                copySelect.setAttribute('data-node-index', i - 1);
                copySelect.innerHTML = '<option value="">Copy to...</option>';
                for (let j = 1; j <= nodeCount; j++) {
                    if (i === j) continue; // Don't copy to self
                    let option = document.createElement('option');
                    option.value = j - 1; // Store target node index
                    option.textContent = `Node ${j}`;
                    copySelect.appendChild(option);
                }
                
                thNode.innerHTML = `Node ${i} / Hostname ${i}<br>${coreInputHtml}`;
                thNode.appendChild(select);
                thNode.appendChild(copySelect);
                headerRow.appendChild(thNode);
            }

            // --- Build Body ---
            body.innerHTML = ''; // Clear existing body
            processes.forEach(processName => {
                let row = body.insertRow();
                row.className = "hover:bg-gray-50";

                let cellProcess = row.insertCell();
                cellProcess.className = "px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900 sticky left-0 bg-white";
                
                // --- Add Info Icon and Tooltip ---
                const info = allProcessInfo[processName]; // <-- FIX: Use allProcessInfo
                let infoHtml = '';
                if (info) {
                    infoHtml = `
                        <div class="info-tooltip-container">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block text-blue-500 ml-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                            </svg>
                            <div class="info-tooltip">
                                <strong class="block">Purpose:</strong>
                                <span class="info-tooltip-content">${info.purpose || 'N/A'}</span>
                                <strong class="block mt-2">Licensed:</strong>
                                <span class="info-tooltip-content">${info.licensed}</span>
                                ${info.notes ? `
                                <strong class="block mt-2">Notes:</strong>
                                <span class="info-tooltip-content">${info.notes}</span>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }
                cellProcess.innerHTML = `${processName} ${infoHtml}`;

                let cellTotal = row.insertCell();
                cellTotal.className = "px-4 py-3 whitespace-nowrap text-sm text-gray-500";
                cellTotal.innerHTML = `<span id="total-${processName}" class="font-bold">0</span>`;

                for (let i = 0; i < nodeCount; i++) {
                    let cellNode = row.insertCell();
                    cellNode.className = "px-4 py-3 whitespace-nowrap text-sm text-gray-500";
                    
                    let defaultValue = 0;
                    if (['gateway', 'tabadmincontroller', 'activationservice', 'authnservice'].includes(processName)) {
                        defaultValue = 1;
                    }
                    
                    // Special handling for 'hyper': make it read-only
                    if (processName === 'hyper') {
                         cellNode.innerHTML = `
                            <input type="number" 
                                   id="input-${processName}-${i}"
                                   class="process-input w-16 rounded-md border-gray-300 shadow-sm sm:text-sm bg-gray-100"
                                   value="0" min="0" readonly disabled
                                   data-process="${processName}"
                                   data-node-index="${i}">
                            <div class="graphic-view hidden text-green-600 font-bold text-lg"></div>
                        `;
                    } else {
                         cellNode.innerHTML = `
                            <input type="number" 
                                   id="input-${processName}-${i}"
                                   class="process-input w-16 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm"
                                   value="${defaultValue}" min="0"
                                   data-process="${processName}"
                                   data-node-index="${i}">
                            <div class="graphic-view hidden text-green-600 font-bold text-lg"></div>
                        `;
                    }
                }
            });

            isGraphicView = false; // Reset view toggle
        }

        function updateAll() {
            updateTotalCounts();
            updateTotalCoreCount();
            updateBestPractices();
        }

        // --- Core Logic Functions ---

        function handleProcessInput(input) {
            const processName = input.dataset.process;
            const nodeIndex = input.dataset.nodeIndex;
            const value = parseInt(input.value, 10);
            
            // Auto-colocation for 'hyper' (Data Engine)
            const dependencies = ['vizqlserver', 'vizportal', 'dataserver', 'backgrounder', 'filestore'];
            if (dependencies.includes(processName) && value > 0) {
                const hyperInput = document.querySelector(`input[data-process="hyper"][data-node-index="${nodeIndex}"]`);
                if (hyperInput) {
                    hyperInput.value = 1;
                    hyperInput.disabled = true;
                    hyperInput.classList.add("bg-gray-100");
                }
            }
            
            // Check if 'hyper' dependency is removed
            if (processName === 'hyper') {
                // User is trying to manually edit hyper. Re-check dependencies.
                checkHyperDependencies(nodeIndex);
            } else {
                // A dependency might have been set to 0
                checkHyperDependencies(nodeIndex);
            }
        }
        
        function checkHyperDependencies(nodeIndex) {
            const dependencies = ['vizqlserver', 'vizportal', 'dataserver', 'backgrounder', 'filestore'];
            let hasDependency = false;
            for (const dep of dependencies) {
                const depInput = document.querySelector(`input[data-process="${dep}"][data-node-index="${nodeIndex}"]`);
                if (depInput && parseInt(depInput.value, 10) > 0) {
                    hasDependency = true;
                    break;
                }
            }
            
            const hyperInput = document.querySelector(`input[data-process="hyper"][data-node-index="${nodeIndex}"]`);
            if (hyperInput) {
                if (hasDependency) {
                    hyperInput.value = 1;
                    hyperInput.disabled = true;
                    hyperInput.classList.add("bg-gray-100");
                } else {
                    hyperInput.value = 0;
                    hyperInput.disabled = false;
                    hyperInput.classList.remove("bg-gray-100");
                }
            }
        }

        function updateTotalCounts() {
            const nodeCount = parseInt(document.getElementById('node-count').value, 10) || 1;
            processes.forEach(processName => {
                let total = 0;
                for (let i = 0; i < nodeCount; i++) {
                    const input = document.querySelector(`input[data-process="${processName}"][data-node-index="${i}"]`);
                    if (input) {
                        total += parseInt(input.value, 10) || 0;
                    }
                }
                const totalEl = document.getElementById(`total-${processName}`);
                if (totalEl) {
                    totalEl.textContent = total;
                }
            });
        }
        
        function updateTotalCoreCount() {
            const nodeCount = parseInt(document.getElementById('node-count').value, 10) || 1;
            let totalCores = 0;
            for (let i = 0; i < nodeCount; i++) {
                const coreInput = document.querySelector(`input.core-count-input[data-node-index="${i}"]`);
                if (coreInput) {
                    totalCores += parseInt(coreInput.value, 10) || 0;
                }
            }
            const totalCoreDisplay = document.getElementById('total-core-display');
            if (totalCoreDisplay) {
                totalCoreDisplay.textContent = totalCores;
            }
        }

        function updateBestPractices() {
            const notesList = document.getElementById('notes-list');
            const notesContainer = document.getElementById('notes-container').querySelector('p');
            notesList.innerHTML = '';
            let displayedNotes = new Set();
            
            const nodeCount = parseInt(document.getElementById('node-count').value, 10) || 1;

            // Now, check rules for each process
            processes.forEach(processName => {
                const ruleset = rules[processName];
                if (!ruleset) return;

                const totalEl = document.getElementById(`total-${processName}`);
                const total = totalEl ? parseInt(totalEl.textContent, 10) : 0;
                
                // Check total rules
                if (ruleset.notes) {
                    ruleset.notes.forEach(note => {
                        if (note.triggerTotal && total >= note.triggerTotal) {
                            addNote(`${processName} (Total): ${note.text}`, displayedNotes);
                        }
                    });
                }

                // Check per-node rules
                if (ruleset.notes) {
                    // Check for per-node value triggers
                    const perNodeNotes = ruleset.notes.filter(n => n.triggerValue);
                    if (perNodeNotes.length > 0) {
                        for (let i = 0; i < nodeCount; i++) {
                            const input = document.querySelector(`input[data-process="${processName}"][data-node-index="${i}"]`);
                            const val = (input && parseInt(input.value, 10)) || 0;
                            
                            perNodeNotes.forEach(note => {
                                // Special check for vizqlserver rule
                                if (processName === 'vizqlserver' && note.triggerValue === 4) {
                                    const coreInput = document.querySelector(`input.core-count-input[data-node-index="${i}"]`);
                                    const coreCount = (coreInput && parseInt(coreInput.value, 10)) || 8;
                                    if (val >= 4 && coreCount < 16) {
                                        addNote(`vizqlserver (Node ${i + 1}): 4+ VizQL Servers is best on 16+ cores (node has ${coreCount}).`, displayedNotes);
                                    }
                                } else if (val >= note.triggerValue) {
                                    addNote(`${processName} (Node ${i + 1}): ${note.text}`, displayedNotes);
                                }
                            });
                        }
                    }
                }
            });

            // Check for "soft" co-location rules per node
            for (let i = 0; i < nodeCount; i++) {
                const vizqlInput = document.querySelector(`input[data-process="vizqlserver"][data-node-index="${i}"]`);
                const vizportalInput = document.querySelector(`input[data-process="vizportal"][data-node-index="${i}"]`);
                const backgrounderInput = document.querySelector(`input[data-process="backgrounder"][data-node-index="${i}"]`);
                const coreInput = document.querySelector(`input.core-count-input[data-node-index="${i}"]`);

                const coreCount = (coreInput && parseInt(coreInput.value, 10)) || 8;
                const vizqlCount = (vizqlInput && parseInt(vizqlInput.value, 10)) || 0;
                const vizportalCount = (vizportalInput && parseInt(vizportalInput.value, 10)) || 0;
                const backgrounderCount = (backgrounderInput && parseInt(backgrounderInput.value, 10)) || 0;

                // Rule: VizQL is present, but VizPortal (App Server) is not
                if (vizqlCount > 0 && vizportalCount === 0) {
                    addNote(`Node ${i + 1}: Has VizQL Server but no VizPortal (Application Server). It is recommended to co-locate them.`, displayedNotes);
                }

                // Rule: Check backgrounder count against cores
                if (backgrounderCount > 0) {
                    if (coreCount === 8 && (backgrounderCount < 4 || backgrounderCount > 6)) {
                        addNote(`backgrounder (Node ${i + 1}): For 8 cores, 4-6 Backgrounders is recommended (currently ${backgrounderCount}).`, displayedNotes);
                    } else if (coreCount === 16 && (backgrounderCount < 8 || backgrounderCount > 12)) {
                        addNote(`backgrounder (Node ${i + 1}): For 16 cores, 8-12 Backgrounders is recommended (currently ${backgrounderCount}).`, displayedNotes);
                    } else if (coreCount < 8 && backgrounderCount > (coreCount / 2)) {
                        addNote(`backgrounder (Node ${i + 1}): ${backgrounderCount} Backgrounders may be high for ${coreCount} cores.`, displayedNotes);
                    }
                }
            }

            // Show or hide the notes container
            if (displayedNotes.size > 0) {
                if(notesContainer) notesContainer.style.display = 'none';
            } else {
                if(notesContainer) notesContainer.style.display = 'block';
                notesList.innerHTML = '<li class="text-sm text-green-600">All checks pass! Configuration looks good.</li>';
            }
        }

        function addNote(message, displayedNotes) {
            if (!displayedNotes.has(message)) {
                displayedNotes.add(message);
                const notesList = document.getElementById('notes-list');
                const li = document.createElement('li');
                li.className = 'text-sm text-yellow-700 p-2 bg-yellow-50 rounded';
                li.textContent = message;
                notesList.appendChild(li);
            }
        }

        function applyTemplate(selectElement) {
            const tplName = selectElement.value;
            const nodeIndex = selectElement.dataset.nodeIndex;
            if (!tplName) return;

            const template = templates[tplName];
            if (!template) return;

            // Reset all inputs for this node to 0
            processes.forEach(processName => {
                const input = document.querySelector(`input[data-process="${processName}"][data-node-index="${nodeIndex}"]`);
                if (input && processName !== 'hyper') { // Don't reset hyper
                    input.value = 0;
                }
            });
            
            // Set core count (if specified in template, otherwise default)
            const coreInput = document.querySelector(`input.core-count-input[data-node-index="${nodeIndex}"]`);
            if (coreInput) {
                coreInput.value = template['cores'] || 8;
            }

            // Apply template values
            for (const processName in template) {
                const input = document.querySelector(`input[data-process="${processName}"][data-node-index="${nodeIndex}"]`);
                if (input) {
                    input.value = template[processName];
                }
            }

            // Reset dropdown
            selectElement.value = "";
            
            // Re-run dependency checks
            checkHyperDependencies(nodeIndex);

            // Update everything
            updateAll();
        }
        
        function handleCopyNode(selectElement) {
            const sourceNodeIndex = selectElement.dataset.nodeIndex;
            const targetNodeIndex = selectElement.value;
            
            if (targetNodeIndex === "") return; // No target selected

            // 1. Copy Core Count
            const sourceCoreInput = document.querySelector(`input.core-count-input[data-node-index="${sourceNodeIndex}"]`);
            const targetCoreInput = document.querySelector(`input.core-count-input[data-node-index="${targetNodeIndex}"]`);
            if (sourceCoreInput && targetCoreInput) {
                targetCoreInput.value = sourceCoreInput.value;
            }

            // 2. Copy all process counts
            processes.forEach(processName => {
                if (processName === 'hyper') return; // Skip hyper, it's automatic
                
                const sourceProcessInput = document.querySelector(`input[data-process="${processName}"][data-node-index="${sourceNodeIndex}"]`);
                const targetProcessInput = document.querySelector(`input[data-process="${processName}"][data-node-index="${targetNodeIndex}"]`);
                
                if (sourceProcessInput && targetProcessInput) {
                    targetProcessInput.value = sourceProcessInput.value;
                }
            });

            // 3. Re-run dependency checks on the target node
            checkHyperDependencies(targetNodeIndex);

            // 4. Reset the dropdown
            selectElement.value = "";

            // 5. Update everything
            updateAll();
        }

        function toggleGraphicView() {
            isGraphicView = !isGraphicView;
            const toggleButton = document.getElementById('toggle-graphic');
            const inputs = document.querySelectorAll('.process-input');
            const graphics = document.querySelectorAll('.graphic-view');

            if (isGraphicView) {
                toggleButton.textContent = 'Toggle Input View';
                toggleButton.classList.remove('bg-gray-200', 'text-gray-800', 'hover:bg-gray-300');
                toggleButton.classList.add('bg-green-600', 'text-white', 'hover:bg-green-700');
                
                inputs.forEach(input => {
                    input.classList.add('hidden');
                    const graphicEl = input.nextElementSibling;
                    const value = parseInt(input.value, 10);
                    
                    let checks = '';
                    if (value > 0 && value <= 4) {
                        checks = '✓'.repeat(value);
                    } else if (value > 4) {
                        checks = `✓ x ${value}`;
                    }
                    graphicEl.textContent = checks;
                    graphicEl.classList.remove('hidden');
                });

            } else {
                toggleButton.textContent = 'Toggle Graphic View';
                toggleButton.classList.add('bg-gray-200', 'text-gray-800', 'hover:bg-gray-300');
                toggleButton.classList.remove('bg-green-600', 'text-white', 'hover:bg-green-700');
                
                inputs.forEach(input => {
                    input.classList.remove('hidden');
                    input.nextElementSibling.classList.add('hidden');
                });
            }
        }

        // --- NEW FUNCTIONS START ---

        function resetGrid() {
            // NEW: Reset node count input to default
            document.getElementById('node-count').value = 4;

            // Re-builds the grid based on the "Nodes" input and resets all values
            buildTopologyGrid(); // This already sets isGraphicView = false
            updateAll();

            // Manually reset the toggle button's appearance
            const toggleButton = document.getElementById('toggle-graphic');
            toggleButton.textContent = 'Toggle Graphic View';
            toggleButton.classList.add('bg-gray-200', 'text-gray-800', 'hover:bg-gray-300');
            toggleButton.classList.remove('bg-green-600', 'text-white', 'hover:bg-green-700');
        }

        function exportConfig() {
            try {
                const nodeCount = parseInt(document.getElementById('node-count').value, 10) || 1;
                let config = {
                    nodeCount: nodeCount,
                    nodes: []
                };

                for (let i = 0; i < nodeCount; i++) {
                    const coreInput = document.querySelector(`input.core-count-input[data-node-index="${i}"]`);
                    let nodeData = {
                        cores: coreInput ? parseInt(coreInput.value, 10) : 8,
                        processes: {}
                    };

                    processes.forEach(processName => {
                        const processInput = document.querySelector(`input[data-process="${processName}"][data-node-index="${i}"]`);
                        if (processInput) {
                            nodeData.processes[processName] = parseInt(processInput.value, 10) || 0;
                        }
                    });
                    config.nodes.push(nodeData);
                }

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "tableau-topology.json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
            } catch (error) {
                console.error("Error exporting config:", error);
            }
        }

        function importConfig(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const config = JSON.parse(e.target.result);

                    if (!config || typeof config.nodeCount !== 'number' || !Array.isArray(config.nodes)) {
                        console.error("Invalid config file format.");
                        return;
                    }

                    // 1. Set node count and rebuild grid
                    document.getElementById('node-count').value = config.nodeCount;
                    buildTopologyGrid(); // This creates all the inputs

                    // 2. Populate the grid
                    for (let i = 0; i < config.nodeCount; i++) {
                        const nodeData = config.nodes[i];
                        if (!nodeData) continue;

                        // Set core count
                        const coreInput = document.querySelector(`input.core-count-input[data-node-index="${i}"]`);
                        if (coreInput && nodeData.cores) {
                            coreInput.value = nodeData.cores;
                        }

                        // Set process counts
                        if (nodeData.processes) {
                            processes.forEach(processName => {
                                const processInput = document.querySelector(`input[data-process="${processName}"][data-node-index="${i}"]`);
                                if (processInput && typeof nodeData.processes[processName] === 'number') {
                                    processInput.value = nodeData.processes[processName];
                                }
                            });
                        }
                    }

                    // 3. Update all totals and rules
                    updateAll();

                } catch (error) {
                    console.error("Error parsing config file:", error);
                }
            };
            reader.readAsText(file);
            
            // Reset file input to allow importing the same file again
            event.target.value = null;
        }

        // --- NEW FUNCTIONS END ---

    </script>
</body>
</html>
